#!/bin/sh
exec scala -deprecation "$0" "$@"
!#
/////////////////////////////////////////////////////////////////////////
// Script to parse CSV files containing street names for Sac County
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// Imports
/////////////////////////////////////////////////////////////////////////
import scala.io.Source
import scala.collection.immutable.List
import scala.collection.mutable.HashMap
import scala.collection.mutable.HashSet

import java.io.File
import java.io.FileWriter
import java.io.BufferedWriter

/////////////////////////////////////////////////////////////////////////
// Filenames to parse
/////////////////////////////////////////////////////////////////////////
val SacCountyStreetNames = "data/centerlines-sac_county.csv"

/////////////////////////////////////////////////////////////////////////
// CSV Column Names and their Indexes
/////////////////////////////////////////////////////////////////////////

val StreetNameIndex = 2
val StreetTypeIndex = 3
val StreetFullIndex = 9
val CityLeftIndex = 10
val CityRightIndex = 11
val ZipLeftIndex = 12
val ZipRightIndex = 13

val RequiredValueStreetNameIndex = 0

val RequiredValues = 	new Pair( StreetNameIndex, "STREETNAME" ) 	:: 
						new Pair( StreetTypeIndex, "STREETTYPE" ) 	:: 
						new Pair( StreetFullIndex, "FULLSTREET" )	:: 
						new Pair( CityLeftIndex, "CITYLEFT" )		:: 
						new Pair( CityRightIndex, "CITYRIGHT" ) 	:: 
						new Pair( ZipLeftIndex, "ZIPLEFT" ) 		::
						new Pair( ZipRightIndex, "ZIPRIGHT" )		:: Nil

/////////////////////////////////////////////////////////////////////////
// Begin Function definitions
/////////////////////////////////////////////////////////////////////////

def selfTest( metadata: Array[ String ] ) = {

	// validate that the data is what we think it is, if this fails print
	// an error message and exit the script
	if( !RequiredValues.forall( value => metadata( value._1 ) == value._2 ) ) {
		println( "ERROR: Sac County street name data file has change, cannot proceed.")
		sys.exit
	}
}

def validEntry( items: Array[ String ], visitedItems: HashSet[ String ] ) :Boolean = {

	// valid entry if the street isn't names UNNAMED, it hasn't been visited yet, and
	// none of the entries are blank
	return items( StreetNameIndex ) != "UNNAMED" && 
		!visitedItems( generateDataKey( items ) ) &&
		items( StreetNameIndex ) != "" &&
		items( StreetTypeIndex ) != "" &&
		items( StreetFullIndex ) != ""
}

def generateDataKey( data: Array[ String ] ) :String = {
	return data( StreetFullIndex )
}


def generateSql( data: String ) = {
  println( data )
  val out = new FileWriter( "sql/streets.sql" )
  out.write( data )
  out.flush
  out.close
}

/////////////////////////////////////////////////////////////////////////
// End Function definitions
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// Begin Script
/////////////////////////////////////////////////////////////////////////

// used to keep track of all the addresses we've visited so we don't record
// duplicates
val visited = new HashSet[String]()

val builder = new StringBuilder();
builder.append( """CONNECT 'jdbc:derby:treasuremaps;create=true';""" )
builder.append( "\nDROP TABLE STREETS;\n" );
builder.append( "CREATE TABLE STREETS (ID INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1), STREET_NAME VARCHAR(20) NOT NULL, STREET_TYPE VARCHAR(10) NOT NULL, STREET_FULL VARCHAR(255) NOT NULL);\n" );

// TODO: Create Indexes

// Iterator containing all the lines of the file
val lines = Source.fromFile( SacCountyStreetNames ).getLines
lines.zipWithIndex.foreach { case( line, lineIndex ) =>

	val splitStr = line.split( "," )
	// perform a self-test on the CSV column definitions ( i.e. the first line )
	if( lineIndex == 0 ) { selfTest( splitStr ) }

	// only handle valid entries, i.e. entries we haven't already seen
	// and street names that are not equal to "UNNAMED"
	else if( validEntry( splitStr, visited ) ) {
		// record a visit for this address
		visited += generateDataKey( splitStr )
		builder.append( " INSERT INTO STREETS (STREET_NAME, STREET_TYPE, STREET_FULL) VALUES ('" )
		builder.append( splitStr( StreetNameIndex ) )
		builder.append( "','" )
		builder.append( splitStr( StreetTypeIndex ) )
		builder.append( "','" )
		builder.append( splitStr( StreetFullIndex ) )
		builder.append( "');" )
		builder.append( "\n" );
	}
}
builder.append( "DISCONNECT;\n" )
builder.append( "EXIT" )
generateSql( builder toString() )
/////////////////////////////////////////////////////////////////////////
// End Script
/////////////////////////////////////////////////////////////////////////